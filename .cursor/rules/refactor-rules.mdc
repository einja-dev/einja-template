---
description: 
globs: 
alwaysApply: true
---
# リファクタリング方針
## DRY原則（Don't Repeat Yourself）

### 基本方針
- 同じコードを2回以上書かない
- 似たような処理は抽象化して再利用可能にする
- 共通のロジックは適切な場所に集約する

### 具体的な実践
- 重複するコードは関数やコンポーネントとして抽出
- 共通のロジックはユーティリティ関数として実装
- 定数は定数ファイルに集約
- 似たような処理は抽象化して再利用可能に
- 共通のバリデーションロジックは共通関数化
- 共通のエラーハンドリングは統一する

## コードスメル（改善すべきコードの特徴）

### 関数・メソッド関連
- 長すぎる関数（20行以上）は分割
- 引数が多すぎる関数（4つ以上）はオブジェクト化を検討
- 戻り値の型が複雑な場合は型定義を明確に
- 副作用のある関数は最小限に

### 制御構造
- 深すぎるネスト（3段階以上）は避ける
- 複雑な条件分岐は早期リターンで簡略化
- マジックナンバーは定数化
- フラグ変数は列挙型（enum）で管理

### コードの品質
- コメントアウトされたコードは削除
- 未使用の変数やインポートは削除
- デッドコードは削除
- 一時変数は適切なスコープで使用

## SOLID原則

### 単一責任の原則（Single Responsibility Principle）
- 1つのクラス/関数は1つの責務のみを持つ
- 複数の責務を持つ場合は分割を検討
- 責務の境界を明確に定義
- 関連する機能は適切にグループ化

### 開放閉鎖の原則（Open-Closed Principle）
- 既存のコードを修正せずに拡張できる設計
- 抽象化とインターフェースを活用
- 新しい機能追加は既存コードの修正を最小限に
- 拡張ポイントを明確に定義

### リスコフの置換原則（Liskov Substitution Principle）
- サブクラスは親クラスの動作を壊さない
- 継承関係は慎重に設計
- サブクラスは親クラスの契約を守る
- 継承よりも委譲を優先

### インターフェース分離の原則（Interface Segregation Principle）
- クライアントが必要としないメソッドを強制しない
- インターフェースは小さく分割
- クライアント固有のインターフェースを提供
- 汎用的なインターフェースは避ける

### 依存性逆転の原則（Dependency Inversion Principle）
- 高レベルのモジュールは低レベルのモジュールに依存しない
- 抽象化に依存する設計
- 依存関係はインターフェースを通じて定義
- 具象クラスへの直接依存を避ける

## リファクタリングの進め方

### 事前準備
- テストカバレッジを確認
- リファクタリング範囲を明確に定義
- 影響範囲を分析
- 段階的なアプローチを計画

### 実施手順
1. テストを書く（既存のテストがなければ）
2. 小さな変更から始める
3. 変更ごとにテストを実行
4. コミット単位を適切に分割
5. コードレビューを受ける

### 注意事項
- 機能追加とリファクタリングは分離
- 大きな変更は段階的に実施
- パフォーマンスへの影響を考慮
- ドキュメントの更新を忘れない
